클래스를 만들고 그 클래스를 사용하기 위해서 인스턴스를 만들기 
new 생성자():
=> 생성자 이름은 클래스 이름과 같습니다.
=> new 를 이용해서 생성자를 호출하면 생성자를 가지고 인스턴스를 만들고 그 주소를 리턴합니다.
보통은 클래스 이름 참조변수 = new 생성자():

변수
1. local variable (지역변수) 
=> 메소드 (이름(){}) , 나 제어문 안에서 만들어지는 변수
=> 자기 영역이 끝나면 메모리에서 제거됩니다.
=> 만들기만 하면 데이터가 없어서 없는 것 처럼 간주되다가 처음 값을 대입할 때 만들어 집니다.
 
2. member variable (멤버 변수)
=> 선언은 클래스 안에서 접근 지정자와 함께 하고 실제 생성은 객체 별로 별도로 소유하는 변수 
=> 초기화 하지 않으면 0이나 0.0 또는 false 또는 null로 자동 초기화가 됩니다.
=> 자신의 맴베에 접근 할 때는 .을 이용해서 접근합니다.

3. static variable (정적변수) 
=>클래스 안에서 static이라는 키워드와 함께 선언하는 변수
=>무조건 1개만 생성됩니다.
=>한번 만들면 프로그램이 종료될 때 까지 메모리에 유지
=>여러 곳에서 공유 목적으로 생성
=>클래스 이름으로 호출해도 되고 객체 이름으로 호출해도 됨
=>객체이름으로 호출하면 eclipse에서는 경고
    경고이유: 쓸때없는 이유로 속도가 느려져서 

**return
=>메소드의 수행이 종료되고 매소드를 호출한 지점으로 돌아오도록 하는 명령어
=>메소드의 수행이 종료된 상태에서 어떤 결과를 호출한 지점으로 넘겨주고자 하면 메소드 이름 앞에 넘겨주고자 하는 데이터의 자료형을 기재하고 return 다음에 결과를 입력해주면 됩니다.
=>메소드의 return이 없을 때는 자료형 대신에 void라고 입력하고 void 메소드는 메소드를 호ㅈ출한 이후에 연속해서 작업을 수행할 수 없습니다.
=>return 되는 데이터가 있으면 그 데이터를 가지고 연속해서 작업을 수행할수 있습니다.

**argument
=>매걔변수라고 번역하는데 매소드를 호출할 때 호출하는 쪽에서 넘겨주어야 하는 데이터
=>매소드를 선언할 때 괄호안에 자료형과 변수명을 기재하면 매소드를 호출할 때 데이터를 넘겨주어야 한다
=>

접근제어자
=>클래스나 인스턴스 변수나 메소드, 클래스 변수나 메소드에 사용해서 사용범위 제한
1) 클래스
=>public: 모든곳에서 사용가능한 클래스
=>생략(default): 자신의 패키지안에서만 사용
=>protected: 상속받은곳에서는 보이고 다른 곳에선 안보임
=>private: 오직 현재 위치에서만 사용

2)인스턴스 변수, 메소드
=>public: 클래스 외부에서 사용가능
=>protected: 상속
=>default: 패키지 내에서는 쓸수있음(패키지 내에서는 public과 같음)
=>private: 외부, 변수는 보통 private로, 메소드는 주로 public으로

**final 필드 
=>값을 정하면 변경불가.

메소드 
=> 전달받은 인수를 처리하여 결과를 돌려주는 작은 프로그램

**static 메소드
=>메소드 결과행 앞에 static을 추가한 메소드
=>클래스 이름으로 호출할수 있는 메소드
=>인스턴스 변수를 사용할수 없음
=>객체 생성 없이 메소드를 사용하기 위해서 생성

**매개 변수 호출 방법
=>매개 변수의 자료형이 value형인지 reference형 인지로 구성
=>call by value: 매개변수의 자료형이 value형인 경우 메소드에서 원본의 데이터를 변경할수 없다.
=>call by reference: 매개변수의 자료형이 참조형인 경우 메소드에서 원본의 데이터를 변경할수 있다.

재귀호출(recursive - recursive call)
=>메소드가 자기자신을 다시 호출하는것
=>메모리 사용량도 늘어나고 속도가 느림
=>코드를 간결화

**피보나치 수열 
=>첫번째와 두번째 항은1
=>세번째 항 부터는 앞 2개의 항의 합
=>위의 규칙을 만족하는 수열을 피보나치 수열이라고 합니다.

1.1.2.3.5.8.13.21.34.55.89......
=>금융에서 이전 데이터를 가져올 때 많이 사용하는 수열입니다.

public int fiboNoRecursion(int n){
int n1=1;
int n2=1;
int result=1;
for(int i=3; i<n+1; i=i+1){
result = n1+n2;
n1=n2;
n2=result;
}
return result;

public int fiboNoRecursion(int n){
if(n==1 || n=2){
return1;
}
else{
return  fiboNoRecursion(n-1)+public int fiboNoRecursion(int n){
int n1=1;
int n2=1;
int result=1;
for(int i=3; i<n+1; i=i+1){
result = n1+n2;
n1=n2;
n2=result;
}
return result;

public int fiboNoRecursion(int n){
if(n==1 || n=2){
return1;
}
else{
return  fiboNoRecursion(n-1)+  fiboNoRecursion(n-2);
 }
}








