**자료구조(Data Structure)
=>데이터를 어떤 방법으로 저장할 것 인지

**Collection
=>데이터의 묶음으로 대표적인 것이 배열

**Enumerator & Iterator
=>둘 다 반복자나 열거자라는 단어로 번역하는데 Java에서는 Enumerator가 예전에 나온 반복자이고 Iterator가 최근에 나온 반복자입니다.
=>예전 API 클래스들은 Enumerator 라고 하고 최근에 나온 API 클래스들은 Iterator 라고 합니다.
=>맨 처음 데이터의 시작 이전 지점(BOF)을 가리키고 있다가 next()를 호출하면 다음 데이터를 가리키는 구조를 가진 포인터

**List 인터페이스
=>데이터를 순서대로 나열하는 자료구조의 상위 인터페이스
=>데이터를 순서대로 나열하는 자료구조 들의 공통된 작업을 위한 메소드 이름만을 가지고 있습니다.
=>Array(배열)도 데이터를 순서대로 나열하는 자료구조인데 크기 변경이 안됩니다.
=>배열의 저장된 데이터 값을 변경은 할 수 있지만 배열의 데이터를 삭제하거나 배열에 데이터를 추가하려면 배열을 복사해서 작업을 수행해야 합니다.
=>배열은 데이터를 반드시 순서대로 연속해서 저장해야 하기 때문입니다.
=>List는 배열의 이러한 단점을 보완하기 위해서 여분의 공간을 확보하고 있다가 데이터가 추가되면 그 여분의 공간을 활용하는 자료구조입니다.
1.공통된 메소드
1)int size(): 데이터 개수 리턴
2)void add(데이터): 데이터를 마지막에 추가
3)데이터 get(인덱스): 인덱스 번째의 데이터를 리턴 
4)void remove(데이터): 삭제
대부분이 빠른 열거를 사용할 수 있습니다.

2.Vector & ArrayList
=>데이터를 순서대로 연속해서 저장하는 List
=>동작하는 메소드나 저장하는 방식은 동일한데 Vector는 MultiThread에  safe 하고 ArrayList는 MultiThread에 unsafe 합니다.
=>Vector는 Legacy Collection이라고 해서 사용을 권장하지 않습니다.

3.Linked List
=>다음 데이터를 가리키는 리스트
=>한방향으로 가리키는 것을 single linked list라고 하고 양방향으로 가리키는 것을 double linked list라고 합니다.
=>java에서는 클래스이름만 LinkedList이고 사용법은 ArrayList와 동일합니다.

4.배열과 ArrayList(Vector) 그리고 LinkedList
=>배열은 다른 List보다 공간 낭비가 적습니다. 배열은 크기 확장이 되지 않기 때문에 여분의 공간을 가지고 있지 않기 때문입니다.
데이터를 중간에 삽입하거나 삭제하는 작업은 복사 작업과 같이 해야 하기 때문에 속도가 느립니다.

=>ArrayList는 연속된 공간에 데이터를 저장하고 여분의 공간을 가지고 데이터를 중간에 삽입이나 삭제를 할 수 있습니다.
대신에 중간에 삽입이나 삭제를 하려면 다른 데이터를 이동시켜야 하기 때문에 시간이 많이 걸립니다.

=>LinkedList는 다음 데이터의 주소를 저장해서 다음 데이터를 찾아가는 자료구조라서 연속된 빈 공간이 없어도 데이터를 저장할 수 있고 중간에 데이터를 삽입하거나 삭제할 때 포인터만 변경되기 때문에 빠르게 작업을 수행할 수 있다는 장점을 가지고 있지만 이전 데이터를 확인하지 않고 다음 데이터를 조회할 수 없기 때문에 접근 속도는 매우 느립니다.

=>데이터의 개수가 변경될 가능성이 없는 경우에는 배열을 사용하고 삽입과 삭제가 빈번히 발생하는 클라이언트 프로그램의 경우 Linked List를 많이 사용하며 읽어내는 속도가 중요한 서버 프로그램의 경우 ArrayList를 많이 사용합니다.

5.List의 정렬
=>sort 메소드를 호출하면 됩니다.
=>정렬을 하려면 크기 비교를 할 수 있는 메소드를 소유하고 있거나 크기 비교를 할 수 있는 인스턴스를 만들어 주어야 합니다.
Comparator 인터페이스를 implements 한 클래스의 인스턴스를 대입하면 됩니다.

6.Stack
=>LIFO(Last In First Out): 마지막에 삽입된 데이터가 가장 먼저 출력되는 자료구조
=>변수 선언 할 때 순서대로 저장하는 용도로 사용
=>메소드 호출했을 때 호출한 곳의 주소 등을 저장
=>스마트 폰 애플리케이션에서 네비게이션이 스택을 이용합니다.
=>java.util.Stack 이라는 클래스로 지원
=>데이터를 삽입하는 메소드: push(데이터)
=>데이터를 삭제하고 꺼내는 메소드: pop()
=>데이터를 삭제하지 않고 꺼내는 메소드: peek()
=>직접 만들어서 사용하는 경우보다는 시스템이 사용하는 경우가 많습니다.

7.Queue
=>FIFO(First In First Out): 먼저 삽입된 데이터가 먼저 출력되는 자료구조
=>스케줄링(작업 순서) 등에 이용
=>java에서는 java.util.Queue 라는 인터페이스를 통해서 제공
=>ArrayList 등이 이 인터페이스를 implements 했고 PriorityQueue(우선순위 큐 - 데이터를 순서대로 정렬해서 저장) 클래스가 Queue 인터페이스를 implements 했습니다.

8.Deque
=>양쪽에서 삽입과 삭제가 가능한 자료구조
=>스크롤 뷰에 사용

=>면접 보러 갈 때는 반드시 숙지
=>C언어로 취업을 하고자 할 때는 LinkedList는 직접 구현 할 수 있어야 합니다.
자기 참조 구조체를 이용해서 구현하면 됩니다.

**Set
=>데이터를 중복없이 저장하는 자료구조
=>데이터를 저장할 때 순서와는 상관없이 해싱이라는 방법을 이용해서 저장
=>데이터를 저장하는 메소드는 있지만 데이터를 가져오는 메소드는 존재하지 않습니다.
=>데이터를 가져올 때는 빠른 열거를 이용해서 전체 데이터를 가져와야 합니다.
=>삭제하는 메소드와 개수를 리턴하는 메소드는 존재
=>Set은 인터페이스이고 Set을 구현한 클래스로는 HashSet(저장된 순서를 알 수 없음), LinkedHashSet(저장된 순서를 기억), TreeSet(크기를 기억)이 있습니다.
=>데이터를 추가하는 메소드는 add 인데 데이터를 추가하는데 실패하면 false를 리턴합니다.
=>데이터를 추가하는데 실패한 경우는 중복된 데이터를 삽입할려고 한 것입니다.
=>직접 사용하는 빈도는 높지 않습니다.

**Map
=>Key 와 Value를 쌍으로 저장하는 자료구조
=>Key는 Set으로 저장됩니다.
=>Key는 중복될 수 없습니다.
=>데이터를 저장하는 클래스 처럼 데이터를 이름과 함께 저장해서 이름으로 빠르게 찾아서 사용할 목적으로 만든 클래스
=>Map은 인터페이스이고 Map을 구현한 클래스로는 HashMap, LinkedHashMap, TreeMap이 있습니다.

1.HashMap
1)생성자
HashMap<Key의 자료형, Value의 자료형>()
=>Key의 자료형은 특별한 경우가 아니면 String 
=>Value의 자료형은 아무런 데이터나 저장할 수 있도록 Object로 하는 경우가 많습니다.

2)주요 메소드
void put(키, 데이터): 키 이름으로 데이터가 저장되는데 동일한 키 이름이 있으면 수정이되고 동일한 이름이 없으면 추가

Object get(키): 키에 해당하는 데이터를 Object 타입으로 리턴
                    키에 해당하는 데이터가 없으면 null을 리턴합니다.
                    리턴되는 데이터가 Object 타입이므로 get 해서 사용할 때는 저장할 때의 자료형으로 강제 형 변환해서 사용해야 합니다.

void remove(키): 키에 해당하는 데이터를 삭제

int size(): 데이터 개수 리턴

Set<키의 자료형> keySet(): 모든 Key 들을 Set으로 만들어서 리턴
















